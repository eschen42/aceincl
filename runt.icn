############################################################################
#
#   File:     runt.icn
#
#   Subject:  Run all the test_*.icn for which there is a matching
#             test_*.std
#
#   Author:   Arthur C. Eschenlauer
#
#   Date:     October 1, 2021
#
############################################################################
#
#   This file is in the public domain.
#
#   SPDX-License-Identifier: CC-PDDC
#     https://spdx.org/licenses/CC-PDDC.html
#
############################################################################
#
#   Working examples, named `test_*.icn`, are in the `tests` directory:
#
#   - `test_*.std` captures the corresponding test's expected output.
#   - `icon runt.icn tests` will run the tests and compare the results to
#      their expected output.
#   - usage: `icon runt.icn [--continue] [--verbose] [<zero or more dirs>]`
#     - By default, tests are located and run in the current working
#       directory.
#       - Otherwise, tests are located and run in the specified directory
#         or directories.
#     - Tests are not run unless an `.icn` file and a `.std` file share
#       exactly the same name.
#     - Use the `--continue` option to run all tests regardless of whether
#       any fail.
#     - Use the `--verbose` option to show both the expected output from
#       the `.std` file and the actual output produced by the test program.
#
############################################################################
#
#   links: popen, showtbl
#   requried includes: fileDirIo.icn
#
############################################################################

$include "fileDirIo.icn"
$define USAGE  "usage: icon runt.icn [--continue] [--verbose] dir_names"
$define USAGE1 "      --continue: run other tests after a test fails"
$define USAGE2 "      --verbose: trace test results"
$define USAGE3 "      --help - print this message"

link popen  # for procedure popen
link showtbl # for procedure showtbl

# flag that exit should produce error status even with --continue argument
global failure

# run all the test_*.icn for which there is a matching test_*.std
procedure main(args)
  local abort       # if !args == "--continue" then write else stop
  local dir         # one member of dirs
  local dirEntry    # entry in current working directory
  local dirListing  # names of files and subdirectores in CWD
  local dirs        # list args matching directory names
  local filExpected # file with expected results, test_*.std
  local filObserved # file producing observed results, test_*.icn
  local linCount    # line counter
  local linExpected # expected line
  local linObsC     # sequence of observed lines
  local linObserved # observed line
  local testName    # name of test, test_*
  local traceout    # if !args == "--verbose" then write else 2
  local timings     # for test-timing report
  local totalTime   # for test-timing report
  if *args < 1 | !args == "--help" then {
    write(USAGE)
    write(USAGE1)
    write(USAGE2)
    write(USAGE3)
    exit(if *args < 1 then 1 else 0)
  }
  traceout := if !args == "--verbose" then write else 2
  abort    := if !args == "--continue" then write_abort else stop
  if traceout === 2
    then write( &errout, "To trace output,  invoke as:   icon "
              , &progname, " --verbose")
  if abort === stop
    then write( &errout, "To run all tests, invoke as:   icon "
              , &progname, " --continue")
  # timing support
  totalTime := -&time
  timings := table(-1)
  # dirs either lists the directory arguments or the current directory
  dirs := []
  every put( dirs, directory_seq(!args) || "/" )
  if *dirs == 0 then dirs := put( dirs, "./" )
  every dir := !dirs
    do {
      chdir(dir) | (write("Could not change to directory: ", dir) & next)
      # For each file in the directory
      every dirEntry := !(dirListing := open(".")) do {
        # All paths should be relative to the directory-under-test
        # Assume it's a file if it begins with test; check tha it ends with .icn
        if dirEntry ?
             dirEntry == ( testName := ="test_" || tab(find(".icn")) ) || =".icn"
          then (
            # Write nothing unless we find a .std file
            filExpected := open( testName || ".std")
            # Report that we will run the test
          , write("\n", testName)
          , timings[testName] := -&time
            # Prepare to generate the observed result lines
          , filObserved := popen( "icon " || testName || ".icn", "r")
            # Create a sequence of expected result lines
          , linObsC := create traceout("observed: ",!filObserved)
          , linCount := 0
            # For each observed result line, abort if expected line does not match
          , ( every linExpected := traceout("expected: ", !filExpected) do {
                linCount +:= 1
                # termination is premature if expected line is not observed
                linObserved := @linObsC | (
                  abort( " ... line ", linCount
                       , ": premature termination, expected: '", linExpected, "'"
                       )
                , break
                )
                # abort when expected line does not match observed
                (
                  abort( " ... line ", linCount, ": '"
                       , linExpected ~== linObserved
                       , "' was produced but '"
                       , linExpected
                       , "' was expected"
                       ) & break
                ) | next
              }
            ) | if linObserved := @linObsC
                  # report unexpected output
                  then abort( " ... line ", linCount
                            , ": unexpected output: '", linObserved, "'"
                            )
                  else timings[testName] +:= &time
          )
      }
      close(\dirListing)
    }
  # from IPL procs showtbl.icn
  showtbl(
    "approx. runtimes, mS", #  1 title      heading title      ""
    timings,                #  2 tbl        table to be shown  NO DEFAULT
    ,                       #  3 sort_type  type of sorting    "ref"/"val"
    ,                       #  4 limit      lines of output    infinite
    ,                       #  5 sort_order increasing?        "incr"/"decr"
    ,                       #  6 posit      first column       "val"/"ref"
    40,                     #  7 w1         width of 1st col   10
    ,                       #  8 w2         width of 2nd col   10
    ,                       #  9 gutter     width between cols 3
    right,                  # 10 f1         f justify 1st col  left
    left,                   # 11 f2         f justify 2nd col  right
    )
  write("\nTotal testing time (milliseconds, with 10 mS resolution): ", totalTime +:= &time)

  # exit code zero unless falure was encountered when abort === write_abort
  exit( \failure | 0)
end

# record that an error occurred
procedure write_abort(ls[])
  failure := 1
  write ! ls
  return failure
end
